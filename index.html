<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PULU-PULU: SINGULARITY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #000;
            color: white; font-family: 'Rajdhani', sans-serif;
            user-select: none; touch-action: none; -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* LAYERS & EFFECTS */
        #bg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* CRT & VIGNETTE */
        body::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 20;
        }
        body::after {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 21; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 15px; box-sizing: border-box; z-index: 30;
        }

        /* HUD */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        .score-display { font-size: 2.5rem; font-weight: 900; color: #fff; line-height: 0.9; letter-spacing: 2px; font-style: italic; }
        .highscore-display { font-size: 0.9rem; color: #ffd700; margin-top: 5px; letter-spacing: 1px; }
        
        .hp-wrapper { display: flex; gap: 10px; margin-top: 10px; }
        .hp-block { display: flex; flex-direction: column; width: 130px; }
        .hp-label { font-size: 0.7rem; font-weight: bold; margin-bottom: 2px; letter-spacing: 1px; text-transform: uppercase; }
        .hp-container {
            height: 8px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2);
            transform: skewX(-20deg); overflow: hidden; position: relative;
        }
        .hp-fill { height: 100%; width: 100%; transition: width 0.1s linear; }
        .p1-hp { background: linear-gradient(90deg, #00f3ff, #0066ff); box-shadow: 0 0 10px #00f3ff; }
        .p2-hp { background: linear-gradient(90deg, #ffaa00, #ff5500); box-shadow: 0 0 10px #ffaa00; }

        .xp-container { position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: #111; z-index: 25; }
        .xp-fill {
            height: 100%; background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%; transition: width 0.2s; box-shadow: 0 0 15px #ff00ff;
        }

        /* CONTROLS AREA */
        .controls-area { position: relative; width: 100%; height: 150px; pointer-events: none; }

        .action-btn {
            position: absolute; bottom: 30px; width: 90px; height: 90px;
            pointer-events: auto; display: flex; justify-content: center; align-items: center;
            font-size: 2.5rem; transition: 0.1s;
            background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: white; backdrop-filter: blur(5px);
            touch-action: manipulation;
        }
        .action-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.1); }
        .action-btn.cooldown { opacity: 0.4; filter: grayscale(1); pointer-events: none; }

        #dash-btn { right: 20px; border-color: #00f3ff; color: #00f3ff; box-shadow: 0 0 20px rgba(0,243,255,0.2); bottom: 40px; }
        #ult-btn { right: 130px; border-color: #ff0055; color: #ff0055; box-shadow: 0 0 20px rgba(255,0,85,0.2); bottom: 20px; width: 70px; height: 70px; font-size: 1.8rem; opacity: 0.5; pointer-events: none; }
        #ult-btn.ready { opacity: 1; pointer-events: auto; animation: pulseBtn 0.5s infinite alternate; background: rgba(255, 0, 85, 0.2); }
        
        .ult-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(255, 0, 85, 0.6); z-index: -1; transition: height 0.2s; border-radius: 50%;
        }

        @keyframes pulseBtn { from { box-shadow: 0 0 10px #ff0055; } to { box-shadow: 0 0 30px #ff0055; } }

        #sound-btn {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; opacity: 0.8; pointer-events: auto; cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2); padding: 5px 15px; border-radius: 20px;
            background: rgba(0,0,0,0.5); font-weight: bold; letter-spacing: 2px;
        }
        
        #boss-warning {
            position: absolute; top: 35%; width: 100%; text-align: center;
            font-family: 'Rajdhani'; font-weight: 900; font-size: 4rem; 
            color: #ff0000; letter-spacing: 5px; display: none;
            text-shadow: 0 0 40px red; animation: glitch 0.2s infinite; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 20px 0;
        }
        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }

        /* MODALS */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 60; pointer-events: auto; padding: 20px; box-sizing: border-box; text-align: center;
        }
        #start-screen { background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%); }
        #game-over-screen { background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); display: none; }

        h1 {
            font-size: 3.5rem; margin: 0 0 20px 0;
            background: linear-gradient(180deg, #fff, #00f3ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px rgba(0, 243, 255, 0.5); text-transform: uppercase; font-weight: 900; letter-spacing: 5px; font-style: italic;
        }
        
        .mode-select { display: flex; flex-direction: column; gap: 15px; margin-top: 30px; width: 80%; max-width: 300px; }

        button.btn-main {
            padding: 20px; font-size: 1.2rem;
            background: rgba(0,0,0,0.5); color: #00f3ff; border: 2px solid #00f3ff;
            font-family: 'Rajdhani', sans-serif; text-transform: uppercase; cursor: pointer;
            letter-spacing: 2px; transition: 0.2s; position: relative; overflow: hidden;
            font-weight: bold; transform: skewX(-10deg); border-radius: 5px;
        }
        button.btn-main:hover, button.btn-main:active { background: #00f3ff; color: #000; box-shadow: 0 0 30px #00f3ff; }

        #upgrade-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto; padding: 10px;
        }
        .cards-container { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; overflow-y: auto; max-height: 80vh; }
        .upgrade-card {
            width: 130px; min-height: 200px; background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(255,255,255,0.1); padding: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer;
            text-align: center; transition: 0.2s; position: relative; overflow: hidden;
            flex-shrink: 0;
        }
        .upgrade-card:active { border-color: #00f3ff; background: rgba(0, 243, 255, 0.1); transform: scale(0.95); }
        .card-icon { font-size: 2.5rem; margin-bottom: 10px; }
        .card-title { font-size: 0.9rem; font-weight: 800; color: #fff; margin-bottom: 5px; text-transform: uppercase; }
        .card-desc { font-size: 0.7rem; color: #aaa; line-height: 1.3; }
        .card-rare { border-color: #ffaa00; }

        /* JOYSTICK VISUALS */
        .joystick {
            position: absolute; width: 120px; height: 120px; border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 60%); 
            border: 2px dashed rgba(255, 255, 255, 0.3);
            display: none; pointer-events: none; z-index: 50;
        }
        .knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            border-radius: 50%; transform: translate(-50%, -50%);
            border: 3px solid rgba(255,255,255,0.8);
        }
        #joy1 .knob { background: rgba(0, 243, 255, 0.5); box-shadow: 0 0 15px #00f3ff; }
        #joy2 .knob { background: rgba(255, 170, 0, 0.5); box-shadow: 0 0 15px #ffaa00; }
        
        .controls-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 0.8rem; display: flex; gap: 30px; text-align: center; letter-spacing: 2px; font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .controls-hint { display: none; }
            h1 { font-size: 2.5rem; }
            .score-display { font-size: 1.8rem; }
            .action-btn { width: 80px; height: 80px; font-size: 1.8rem; }
            #ult-btn { right: 110px; width: 65px; height: 65px; font-size: 1.5rem; bottom: 25px; }
            #dash-btn { right: 20px; bottom: 40px; }
            .hp-block { width: 90px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div class="xp-container"><div class="xp-fill" id="xp-bar"></div></div>
    
    <div id="joy1" class="joystick"><div class="knob"></div></div>
    <div id="joy2" class="joystick"><div class="knob"></div></div>
    
    <div id="boss-warning">‚ö†Ô∏è SINGULARITY DETECTED ‚ö†Ô∏è</div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                <div class="score-display" id="score-display">0</div>
                <div class="highscore-display">HI: <span id="highscore-val">0</span></div>
                <div class="hp-wrapper">
                    <div class="hp-block" id="hp-c-1">
                        <div class="hp-label" style="color:#00f3ff">UNIT 01</div>
                        <div class="hp-container"><div class="hp-fill p1-hp" id="hp-bar-1"></div></div>
                    </div>
                    <div class="hp-block" id="hp-c-2" style="display:none;">
                        <div class="hp-label" style="color:#ffaa00">UNIT 02</div>
                        <div class="hp-container"><div class="hp-fill p2-hp" id="hp-bar-2"></div></div>
                    </div>
                </div>
            </div>
            
            <div id="sound-btn" onclick="toggleSound()">SFX: ON</div>

            <div style="text-align:right;">
                <div class="level-display" style="font-size:1.5rem; font-weight:800; color:#fff; font-style:italic;">WAVE <span id="lvl-display" style="color:#00f3ff">1</span></div>
                <div style="font-size:1rem; color:#888; font-family:monospace; letter-spacing:1px;" id="timer-display">00:00</div>
            </div>
        </div>
        
        <div class="controls-area">
            <div id="ult-btn" class="action-btn" ontouchstart="triggerUltimate(event)" onmousedown="triggerUltimate(event)">
                ‚ò¢Ô∏è<div class="ult-fill" id="ult-fill"></div>
            </div>
            <div id="dash-btn" class="action-btn" ontouchstart="triggerDash(event)" onmousedown="triggerDash(event)">‚ö°</div>
        </div>

        <div class="controls-hint" id="controls-hint">
            <span>P1: WASD</span> ‚Ä¢ <span>P2: ARROWS</span> ‚Ä¢ <span>SPACE: DASH</span> ‚Ä¢ <span>E: NUKE</span>
        </div>
    </div>

    <div id="start-screen" class="screen-overlay">
        <h1 style="line-height:1;">PULU-PULU<br><span style="font-size:0.5em; color:#00f3ff;">SINGULARITY</span></h1>
        <p style="opacity:0.7; font-size:1rem; margin-bottom:20px;">Neon Bullet Hell Survival</p>
        <div class="mode-select">
            <button class="btn-main" onclick="startGame(1)">SOLO DIVE</button>
            <button class="btn-main" onclick="startGame(2)">DUO SYNC</button>
        </div>
    </div>

    <div id="game-over-screen" class="screen-overlay">
        <h1 style="color:#ff0055; font-size:3.5rem; text-shadow:0 0 30px red;">MISSION FAILED</h1>
        <div style="font-size:2rem; margin: 20px 0; color:#fff; font-weight:800;" id="final-score">0</div>
        <button class="btn-main" onclick="location.reload()">SYSTEM REBOOT</button>
    </div>

    <div id="upgrade-modal">
        <h2 style="font-size:2.5rem; color:#fff; margin-bottom:10px; text-shadow:0 0 30px #00f3ff; font-weight:900;">UPGRADE</h2>
        <div class="cards-container" id="cards-container"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const joy1 = document.getElementById('joy1');
        const joy2 = document.getElementById('joy2');
        const dashBtn = document.getElementById('dash-btn');
        const ultBtn = document.getElementById('ult-btn');
        const ultFill = document.getElementById('ult-fill');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isMuted = false;
        let musicInterval;

        function toggleSound() {
            isMuted = !isMuted;
            document.getElementById('sound-btn').innerText = isMuted ? "SFX: OFF" : "SFX: ON";
            if(!isMuted && audioCtx.state === 'suspended') audioCtx.resume();
        }

        const Sound = {
            play: (freq, type, dur, vol=0.1, slide=0) => {
                if(isMuted) return;
                const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if(slide !== 0) o.frequency.linearRampToValueAtTime(slide, audioCtx.currentTime + dur);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
            },
            shoot: (type) => {
                let f = 500; 
                if(type==='SHOTGUN') Sound.play(200, 'sawtooth', 0.1, 0.1, 50);
                else if(type==='RAILGUN') Sound.play(900, 'square', 0.2, 0.05, 300);
                else if(type==='MISSILE') Sound.play(150, 'triangle', 0.4, 0.1, 400);
                else if(type==='CHAIN') Sound.play(700, 'sine', 0.15, 0.05, 1200); 
                else Sound.play(500, 'triangle', 0.08, 0.05, 200);
            },
            heal: () => Sound.play(400, 'sine', 0.4, 0.1, 800),
            explode: () => Sound.play(60, 'sawtooth', 0.5, 0.2, 10),
            dash: () => Sound.play(200, 'square', 0.2, 0.05, 600),
            nuke: () => Sound.play(50, 'sawtooth', 3.0, 0.5, 10),
            levelup: () => [523, 659, 783, 1046].forEach((f,i)=>setTimeout(()=>Sound.play(f,'square',0.15,0.05), i*100)),
            // FIX: Added missing gameover function
            gameover: () => [300, 250, 200, 150].forEach((f,i)=>setTimeout(()=>Sound.play(f,'sawtooth',0.3,0.2), i*150)),
            bassTick: () => {
                if(gameState !== 'PLAYING' || isMuted) return;
                const root = sharedLevel % 2 === 0 ? 49 : 55; 
                const note = [root, root, root, root, root+7, root+7, root-5, root-5][Math.floor(audioCtx.currentTime * 4) % 8];
                Sound.play(note, 'sawtooth', 0.15, 0.03, note-10);
            }
        };

        // --- GAME STATE ---
        let gameState = 'START';
        let playerCount = 1;
        let frameCount = 0;
        let score = 0;
        let highScore = localStorage.getItem('pulu_highscore') || 0;
        document.getElementById('highscore-val').innerText = highScore;
        let timeElapsed = 0;
        let lastTime = 0;
        let bossActive = false;
        let shake = 0;
        let glitch = 0;
        let timeScale = 1.0; 

        // --- ENTITIES ---
        let shockwaves = [];
        let players = [];
        let bullets = [], enemies = [], particles = [], xps = [], healthPacks = [], floatingTexts = [], gridOffset = {x:0, y:0};
        let gridHue = 180; 

        const basePlayer = {
            id: 0, x: 0, y: 0, radius: 16, color: '#00f3ff',
            baseSpeed: 5.5, speed: 5.5, hp: 100, maxHp: 100, 
            isDashing: false, dashTimer: 0, dashCooldown: 0,
            fireRate: 8, lastShot: 0, 
            weapon: 'BLASTER', damage: 15, bulletSpeed: 18, 
            angle: 0, dead: false
        };

        let sharedXP = 0, xpToNext = 30, sharedLevel = 1, ultimateCharge = 0, maxUltimate = 100, sharedOrbitals = 0;

        const keys = {};
        const touches = {}; 

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        canvas.addEventListener('touchstart', handleTouch, {passive:false});
        canvas.addEventListener('touchmove', handleTouch, {passive:false});
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) delete touches[e.changedTouches[i].identifier];
            updateJoysticksUI();
        });

        function handleTouch(e) {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                touches[t.identifier] = { x: t.clientX, y: t.clientY, startX: touches[t.identifier]?.startX || t.clientX, startY: touches[t.identifier]?.startY || t.clientY };
            }
            updateJoysticksUI();
        }

        function updateJoysticksUI() {
            let p1Touch = null, p2Touch = null;
            const mid = window.innerWidth / 2;
            for(let id in touches) {
                const t = touches[id];
                if(t.startX < mid && !p1Touch) p1Touch = t;
                else if(t.startX >= mid && !p2Touch) p2Touch = t;
            }
            if(p1Touch) {
                joy1.style.display = 'block'; joy1.style.left = p1Touch.startX+'px'; joy1.style.top = p1Touch.startY+'px';
                const dx = p1Touch.x - p1Touch.startX; const dy = p1Touch.y - p1Touch.startY;
                joy1.querySelector('.knob').style.transform = `translate(calc(-50% + ${Math.max(-40, Math.min(40, dx))}px), calc(-50% + ${Math.max(-40, Math.min(40, dy))}px))`;
            } else joy1.style.display = 'none';

            if(playerCount > 1 && p2Touch) {
                joy2.style.display = 'block'; joy2.style.left = p2Touch.startX+'px'; joy2.style.top = p2Touch.startY+'px';
                const dx = p2Touch.x - p2Touch.startX; const dy = p2Touch.y - p2Touch.startY;
                joy2.querySelector('.knob').style.transform = `translate(calc(-50% + ${Math.max(-40, Math.min(40, dx))}px), calc(-50% + ${Math.max(-40, Math.min(40, dy))}px))`;
            } else joy2.style.display = 'none';
        }

        function getJoystickVector(side) {
            const mid = window.innerWidth / 2;
            for(let id in touches) {
                const t = touches[id];
                if( (side === 1 && t.startX < mid) || (side === 2 && t.startX >= mid) ) {
                    let dx = t.x - t.startX; let dy = t.y - t.startY;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if(len > 10) return { x: dx/len, y: dy/len };
                }
            }
            return { x: 0, y: 0 };
        }

        // --- INIT ---
        function startGame(count) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('upgrade-modal').style.display = 'none';
            
            playerCount = count;
            gameState = 'PLAYING'; score = 0; timeElapsed = 0; frameCount = 0; bossActive = false;
            timeScale = 1.0;
            
            sharedLevel = 1; sharedXP = 0; xpToNext = 30; ultimateCharge = 0; sharedOrbitals = 0;
            
            players = [];
            for(let i=0; i<count; i++) {
                let p = JSON.parse(JSON.stringify(basePlayer));
                p.id = i;
                p.x = canvas.width/2 + (i===0 ? -60 : 60);
                p.y = canvas.height/2;
                p.color = i===0 ? '#00f3ff' : '#ffaa00';
                p.weapon = 'BLASTER';
                players.push(p);
            }

            document.getElementById('hp-c-2').style.display = count > 1 ? 'flex' : 'none';
            bullets = []; enemies = []; particles = []; xps = []; healthPacks = []; floatingTexts = []; shockwaves = [];
            
            if(musicInterval) clearInterval(musicInterval);
            musicInterval = setInterval(Sound.bassTick, 250);

            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (gameState !== 'PLAYING') return;
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            
            if (deltaTime >= 16) { 
                lastTime = timestamp;
                if (timeScale < 1.0) timeScale += 0.01; else timeScale = 1.0;

                if(frameCount % 60 === 0) {
                    timeElapsed++;
                    document.getElementById('timer-display').innerText = new Date(timeElapsed*1000).toISOString().substr(14,5);
                    if (timeElapsed > 10 && timeElapsed % 60 === 0 && !bossActive) { 
                        document.getElementById('boss-warning').style.display = 'block';
                        setTimeout(() => { document.getElementById('boss-warning').style.display = 'none'; spawnBoss(); }, 3000);
                    }
                }
                updateGame(timeScale);
            }

            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if(glitch > 0) drawGlitch(); else { drawDistortedGrid(); drawEntities(); }

            if (shake > 0) {
                ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); ctx.restore();
                shake *= 0.9; if(shake < 0.5) shake = 0;
            }
            if(glitch > 0) glitch--;

            requestAnimationFrame(gameLoop);
        }

        function updateGame(ts) {
            frameCount++;
            gridHue = (gridHue + 0.5 * ts) % 360;
            updatePlayers(ts); updateEnemies(ts); updateBullets(ts); updateParticles(ts);
            updatePickups(ts); updateFloatingTexts(ts); updateOrbitals(ts); updateShockwaves(ts);
        }

        function addShockwave(x, y) { shockwaves.push({x, y, radius: 1, maxRadius: 200, alpha: 1}); }
        function updateShockwaves(ts) {
            for(let i=shockwaves.length-1; i>=0; i--) {
                let s = shockwaves[i]; s.radius += 8 * ts; s.alpha -= 0.04 * ts;
                if(s.alpha <= 0) shockwaves.splice(i, 1);
            }
        }

        function drawGlitch() {
            ctx.save();
            const offX = (Math.random() - 0.5) * 10;
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = 'red'; ctx.translate(offX, 0); drawDistortedGrid(); drawEntities();
            ctx.translate(-offX * 2, 0); ctx.fillStyle = 'blue'; drawDistortedGrid(); drawEntities();
            ctx.restore();
        }

        function drawDistortedGrid() {
            ctx.strokeStyle = `hsl(${gridHue}, 70%, 20%)`; ctx.lineWidth = 1;
            const sz = 60;
            if(players[0] && !players[0].dead) {
                gridOffset.x -= Math.cos(players[0].angle) * (players[0].speed * 0.2);
                gridOffset.y -= Math.sin(players[0].angle) * (players[0].speed * 0.2);
            }
            const offX = gridOffset.x % sz; const offY = gridOffset.y % sz;
            ctx.beginPath();
            const cols = Math.ceil(canvas.width / sz) + 2; const rows = Math.ceil(canvas.height / sz) + 2;
            for(let x = -1; x < cols; x++) {
                let bx = x * sz + offX;
                for(let y = -1; y < rows; y++) {
                    let by = y * sz + offY; let p = distortPoint(bx, by);
                    if(y === -1) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
            }
            for(let y = -1; y < rows; y++) {
                let by = y * sz + offY;
                for(let x = -1; x < cols; x++) {
                    let bx = x * sz + offX; let p = distortPoint(bx, by);
                    if(x === -1) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
            }
            ctx.stroke();
        }

        function distortPoint(x, y) {
            let dx = 0, dy = 0;
            shockwaves.forEach(s => {
                const dist = Math.hypot(x - s.x, y - s.y);
                if(dist < s.radius + 50 && dist > s.radius - 20) {
                    const force = 30 * s.alpha; const angle = Math.atan2(y - s.y, x - s.x);
                    dx += Math.cos(angle) * force; dy += Math.sin(angle) * force;
                }
            });
            return {x: x + dx, y: y + dy};
        }

        function drawEntities() {
            xps.forEach(x => { ctx.fillStyle = '#0aff00'; ctx.beginPath(); ctx.arc(x.x, x.y, 4, 0, Math.PI*2); ctx.fill(); });
            healthPacks.forEach(h => { ctx.fillStyle = '#ff0055'; ctx.font = '30px Arial'; ctx.fillText('‚úö', h.x-10, h.y+10); });
            enemies.forEach(e => drawEnemy(e));
            players.forEach(p => { if(!p.dead) drawDrone(p); });
            bullets.forEach(b => {
                ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Math.atan2(b.vy, b.vx));
                ctx.fillStyle = b.color; ctx.shadowBlur = 10; ctx.shadowColor = b.color;
                if(b.type === 'RAILGUN') ctx.fillRect(-20, -2, 40, 4);
                else if(b.type === 'MISSILE') { ctx.fillStyle='#fff'; ctx.fillRect(-5, -3, 10, 6); }
                else if(b.type === 'CHAIN') { ctx.fillStyle='#0ff'; ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill(); }
                else if(b.type === 'BOSS') { ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill(); }
                else ctx.fillRect(-5, -2, 10, 4);
                ctx.restore(); ctx.shadowBlur = 0;
            });
            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1; });
            ctx.font = 'bold 20px Rajdhani';
            floatingTexts.forEach(t => { ctx.fillStyle = t.color; ctx.globalAlpha = t.life/40; ctx.fillText(t.text, t.x, t.y); ctx.globalAlpha = 1; });
        }
        
        function drawDrone(p) {
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            if(p.isDashing || frameCount % 3 === 0) {
                ctx.fillStyle = p.color; ctx.globalAlpha = 0.5;
                ctx.beginPath(); ctx.arc(-20, 0, p.radius*0.8, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
            }
            ctx.fillStyle = '#000'; ctx.lineWidth = 3; ctx.strokeStyle = p.color; ctx.shadowBlur = 20; ctx.shadowColor = p.color;
            ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 15); ctx.lineTo(-5, 0); ctx.lineTo(-10, -15); ctx.closePath();
            ctx.fill(); ctx.stroke();
            if(p.weapon === 'SHOTGUN') { ctx.fillStyle = '#fff'; ctx.fillRect(0, -10, 15, 4); ctx.fillRect(0, 6, 15, 4); } 
            else if(p.weapon === 'RAILGUN') { ctx.fillStyle = '#f0f'; ctx.fillRect(5, -2, 25, 4); }
            else if(p.weapon === 'CHAIN') { ctx.fillStyle = '#0ff'; ctx.fillRect(5, -2, 15, 4); ctx.beginPath(); ctx.arc(20,0,4,0,Math.PI*2); ctx.fill(); }
            ctx.restore(); ctx.shadowBlur = 0;
        }

        function drawEnemy(e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
            ctx.fillStyle = e.color; ctx.shadowBlur = 10; ctx.shadowColor = e.color;
            if (e.type === 'gravity') {
                ctx.beginPath(); ctx.arc(0,0, e.radius, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, e.radius + Math.sin(frameCount*0.2)*5, 0, Math.PI*2); ctx.stroke();
            } else if (e.type === 'stealth') {
                ctx.globalAlpha = 0.3 + Math.abs(Math.sin(frameCount*0.1))*0.7; // Blink effect
                ctx.beginPath(); ctx.moveTo(e.radius, 0); ctx.lineTo(-e.radius, e.radius); ctx.lineTo(-e.radius, -e.radius); ctx.fill();
                ctx.globalAlpha = 1.0;
            } else if (e.type === 'splitter') {
                ctx.beginPath(); ctx.arc(-10, 0, 10, 0, Math.PI*2); ctx.arc(10, 0, 10, 0, Math.PI*2); ctx.fill();
            } else if (e.type === 'boss') {
                ctx.beginPath(); for (let k = 0; k < 8; k++) ctx.lineTo(e.radius * Math.cos(k * Math.PI / 4), e.radius * Math.sin(k * Math.PI / 4)); ctx.fill();
                ctx.rotate(frameCount * 0.1); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.rect(-30,-30,60,60); ctx.stroke();
            } else if (e.type === 'tank') {
                ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2); ctx.fillStyle = '#000'; ctx.fillRect(-5,-5,10,10);
            } else if (e.type === 'hunter') {
                ctx.beginPath(); ctx.moveTo(e.radius, 0); ctx.lineTo(-e.radius, e.radius/1.5); ctx.lineTo(-e.radius, -e.radius/1.5); ctx.fill();
            } else {
                ctx.beginPath(); for(let i=0; i<6; i++) { const angle = (i/6)*Math.PI*2; ctx.lineTo(Math.cos(angle)*e.radius, Math.sin(angle)*e.radius); } ctx.fill();
            }
            ctx.restore(); ctx.shadowBlur = 0;
        }

        function updatePlayers(ts) {
            let aliveCount = 0;
            players.forEach(p => {
                if(p.dead) return;
                aliveCount++;

                let dx = 0, dy = 0;
                if(p.id === 0) {
                    if(keys['w']) dy -= 1; if(keys['s']) dy += 1; if(keys['a']) dx -= 1; if(keys['d']) dx += 1;
                    const tv = getJoystickVector(1); if(tv.x||tv.y) { dx=tv.x; dy=tv.y; }
                } else {
                    if(keys['arrowup']) dy -= 1; if(keys['arrowdown']) dy += 1; if(keys['arrowleft']) dx -= 1; if(keys['arrowright']) dx += 1;
                    const tv = getJoystickVector(2); if(tv.x||tv.y) { dx=tv.x; dy=tv.y; }
                }

                const len = Math.sqrt(dx*dx + dy*dy);
                let spd = p.isDashing ? p.baseSpeed * 3 : p.baseSpeed;
                if(len > 0 && !p.isDashing) { dx /= len; dy /= len; }
                
                // Physics movement
                p.x += dx * spd * ts; p.y += dy * spd * ts;
                p.x = Math.max(p.radius, Math.min(canvas.width - p.radius, p.x));
                p.y = Math.max(p.radius, Math.min(canvas.height - p.radius, p.y));

                if(len > 0) p.angle = Math.atan2(dy, dx);

                if(p.isDashing) {
                    p.dashTimer -= ts; if(p.dashTimer <= 0) p.isDashing = false;
                    spawnParticles(p.x, p.y, 2, p.color);
                }
                if(p.dashCooldown > 0) p.dashCooldown -= ts;

                // FIX: Removed / ts so time dilation doesn't reduce fire rate, making player feel faster
                if(frameCount - p.lastShot > p.fireRate) { shoot(p); p.lastShot = frameCount; }
            });

            if(aliveCount === 0 && playerCount > 0) gameOver();
            updateUI();
        }

        function triggerDash(e) {
            if (gameState !== 'PLAYING') return;
            players.forEach(p => {
                if(!p.dead && p.dashCooldown <= 0) {
                    p.isDashing = true; p.dashTimer = 10; p.dashCooldown = 60;
                    Sound.dash();
                }
            });
            dashBtn.classList.add('cooldown');
            setTimeout(() => dashBtn.classList.remove('cooldown'), 1000);
        }

        function triggerUltimate(e) {
            if (gameState !== 'PLAYING' || ultimateCharge < maxUltimate) return;
            Sound.nuke();
            addShockwave(canvas.width/2, canvas.height/2);
            enemies.forEach(e => { e.hp -= 200; spawnFloatingText(e.x, e.y, "CRITICAL", "#ff0055"); });
            ultimateCharge = 0;
            glitch = 10; shake = 20; timeScale = 0.1; 
            updateUI();
        }

        function shoot(p) {
            Sound.shoot(p.weapon);
            p.x -= Math.cos(p.angle) * 2; p.y -= Math.sin(p.angle) * 2; 

            let target = null, minDist = 800;
            enemies.forEach(e => { const d = Math.hypot(e.x - p.x, e.y - p.y); if(d < minDist) { minDist = d; target = e; } });
            let angle = p.angle;
            if(target) angle = Math.atan2(target.y - p.y, target.x - p.x);

            if (p.weapon === 'SHOTGUN') {
                for(let i=-2; i<=2; i++) {
                    bullets.push({ x: p.x, y: p.y, vx: Math.cos(angle + i*0.15)*p.bulletSpeed, vy: Math.sin(angle + i*0.15)*p.bulletSpeed, damage: p.damage * 0.6, life: 25, color: '#ffff00', type: 'SHOTGUN' });
                }
            } else if (p.weapon === 'RAILGUN') {
                bullets.push({ x: p.x, y: p.y, vx: Math.cos(angle)*p.bulletSpeed*2, vy: Math.sin(angle)*p.bulletSpeed*2, damage: p.damage * 3, life: 60, color: '#ff00ff', type: 'RAILGUN', pierce: 10 });
            } else if (p.weapon === 'MISSILE') {
                bullets.push({ x: p.x, y: p.y, vx: Math.cos(angle)*p.bulletSpeed*0.5, vy: Math.sin(angle)*p.bulletSpeed*0.5, damage: p.damage * 2, life: 100, color: '#ffaa00', type: 'MISSILE', target: target });
            } else if (p.weapon === 'CHAIN') {
                bullets.push({ x: p.x, y: p.y, vx: Math.cos(angle)*p.bulletSpeed*1.2, vy: Math.sin(angle)*p.bulletSpeed*1.2, damage: p.damage, life: 50, color: '#00ffff', type: 'CHAIN', chainCount: 3 });
            } else { 
                bullets.push({ x: p.x, y: p.y, vx: Math.cos(angle)*p.bulletSpeed, vy: Math.sin(angle)*p.bulletSpeed, damage: p.damage, life: 60, color: p.color, type: 'BLASTER' });
            }
        }

        function updateBullets(ts) {
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                if(b.type === 'MISSILE' && b.target && enemies.includes(b.target)) {
                    let angle = Math.atan2(b.target.y - b.y, b.target.x - b.x);
                    b.vx += Math.cos(angle) * 0.5 * ts; b.vy += Math.sin(angle) * 0.5 * ts;
                    const s = Math.hypot(b.vx, b.vy); if(s > 10) { b.vx = (b.vx/s)*10; b.vy = (b.vy/s)*10; }
                    spawnParticles(b.x, b.y, 1, '#ffaa00');
                }
                
                b.x += b.vx * ts; b.y += b.vy * ts; b.life -= ts;
                
                // Remove out of bounds or dead
                if(b.life <= 0 || b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i,1); continue; }

                // Check collision with players (for boss bullets)
                if(b.type === 'BOSS') {
                    for(let p of players) {
                        if(!p.dead && Math.hypot(p.x - b.x, p.y - b.y) < p.radius + 5) {
                            if(!p.isDashing) {
                                p.hp -= 10;
                                shake = 5;
                                spawnFloatingText(p.x, p.y, "-10", "#ff0000");
                                bullets.splice(i, 1);
                                if(p.hp <= 0) { p.dead = true; Sound.explode(); }
                            }
                            break;
                        }
                    }
                    continue; // Boss bullets don't hit enemies
                }

                // Check collision with enemies
                for(let j=enemies.length-1; j>=0; j--) {
                    let e = enemies[j];
                    if(Math.hypot(e.x - b.x, e.y - b.y) < e.radius + 10) {
                        e.hp -= b.damage; spawnParticles(b.x, b.y, 3, b.color); spawnFloatingText(e.x, e.y, Math.floor(b.damage), '#fff');
                        if(b.type === 'MISSILE') { addShockwave(b.x, b.y); Sound.explode(); }
                        
                        // Chain Lightning Logic
                        if(b.type === 'CHAIN' && b.chainCount > 0) {
                            // Find next nearest enemy
                            let bestDist = 300; let nextTarget = null;
                            enemies.forEach(ne => {
                                if(ne !== e) {
                                    let d = Math.hypot(ne.x - b.x, ne.y - b.y);
                                    if(d < bestDist) { bestDist = d; nextTarget = ne; }
                                }
                            });
                            if(nextTarget) {
                                let ang = Math.atan2(nextTarget.y - b.y, nextTarget.x - b.x);
                                b.vx = Math.cos(ang) * 20; b.vy = Math.sin(ang) * 20;
                                b.chainCount--;
                                b.life = 30; // Extend life for jump
                                // Draw Lightning Visual
                                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(nextTarget.x, nextTarget.y); ctx.stroke();
                                continue; // Don't delete bullet yet
                            }
                        }

                        if(!b.pierce) bullets.splice(i,1); else b.pierce--;
                        if(e.hp <= 0) killEnemy(j);
                        break;
                    }
                }
            }
        }

        function updateEnemies(ts) {
            if(frameCount % (bossActive ? 200 : Math.max(15, 50 - timeElapsed/2)) === 0) spawnEnemy();

            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                
                // BOSS LOGIC
                if(e.type === 'boss') {
                    e.bossTimer = (e.bossTimer || 0) + ts;
                    if(e.bossTimer > 60) { // Shoot every ~1 sec
                        e.bossTimer = 0;
                        for(let k=0; k<12; k++) {
                            let ang = (k/12)*Math.PI*2 + frameCount*0.05;
                            bullets.push({x: e.x, y: e.y, vx: Math.cos(ang)*5, vy: Math.sin(ang)*5, type: 'BOSS', life: 100, color: '#ff0000'});
                        }
                    }
                }

                let target = null, minDist = Infinity;
                players.forEach(p => { if(!p.dead) { let d = Math.hypot(p.x - e.x, p.y - e.y); if(d < minDist) { minDist = d; target = p; } } });

                if(target) {
                    if (e.type === 'gravity') {
                        if (minDist < 300) {
                            target.x -= (target.x - e.x) * 0.015 * ts; // Stronger pull
                            target.y -= (target.y - e.y) * 0.015 * ts;
                        }
                    } else if (e.type === 'stealth') {
                        if (minDist > 150) e.alpha = 0.1; // Almost invisible
                        else e.alpha = 1.0; // Visible when close
                        let angle = Math.atan2(target.y - e.y, target.x - e.x);
                        e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
                    } else {
                        let angle = Math.atan2(target.y - e.y, target.x - e.x);
                        e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
                        e.angle += 0.05 * ts;
                    }
                }

                players.forEach(p => {
                    if(!p.dead && Math.hypot(p.x - e.x, p.y - e.y) < p.radius + e.radius) {
                        if(!p.isDashing && frameCount % 30 === 0) {
                            p.hp -= e.dmg; shake = 5; glitch = 2; spawnFloatingText(p.x, p.y, `-${e.dmg}`, '#ff0000');
                            if(p.hp <= 0) { p.dead = true; spawnParticles(p.x, p.y, 40, p.color); Sound.explode(); }
                        }
                    }
                });
            }
        }

        function spawnEnemy() {
            const side = Math.floor(Math.random()*4);
            let x, y;
            if(side===0) { x = Math.random()*canvas.width; y = -50; } else if(side===1) { x = canvas.width+50; y = Math.random()*canvas.height; }
            else if(side===2) { x = Math.random()*canvas.width; y = canvas.height+50; } else { x = -50; y = Math.random()*canvas.height; }

            let stats = { hp: 20 + timeElapsed, speed: 2.5, radius: 18, color: '#ff2e63', type: 'basic', dmg: 10, xp: 10 };
            if(bossActive) return; 

            const roll = Math.random();
            if(timeElapsed > 30 && roll > 0.85) { stats.color = '#00ccff'; stats.hp *= 4; stats.speed = 1.2; stats.radius = 25; stats.type = 'tank'; stats.xp = 30; }
            else if(timeElapsed > 45 && roll > 0.7 && roll < 0.85) { stats.color = '#00ff00'; stats.hp *= 0.8; stats.speed = 3.0; stats.radius = 15; stats.type = 'splitter'; stats.xp = 20; }
            else if(timeElapsed > 60 && roll > 0.6 && roll < 0.7) { stats.color = '#ffcc00'; stats.hp *= 0.5; stats.speed = 5.0; stats.radius = 12; stats.type = 'hunter'; stats.xp = 20; }
            else if(timeElapsed > 75 && roll > 0.9) { stats.color = '#aa00ff'; stats.hp *= 5; stats.speed = 0.5; stats.radius = 30; stats.type = 'gravity'; stats.xp = 50; }
            else if(timeElapsed > 90 && roll > 0.5 && roll < 0.6) { stats.color = '#555555'; stats.hp = 15; stats.speed = 3.5; stats.radius = 14; stats.type = 'stealth'; stats.xp = 25; }
            
            enemies.push({ x, y, ...stats, angle: 0 });
        }

        function spawnBoss() {
            bossActive = true;
            enemies.push({ x: canvas.width/2, y: -100, hp: 3000 + timeElapsed*20, speed: 0.8, radius: 80, color: '#ff0000', type: 'boss', dmg: 40, xp: 1000, angle: 0, bossTimer: 0 });
        }

        function killEnemy(idx) {
            let e = enemies[idx];
            if(e.type === 'boss') { bossActive = false; addShockwave(e.x, e.y); shake = 20; timeScale = 0.1; }
            if(e.type === 'gravity') { addShockwave(e.x, e.y); Sound.nuke(); } // Mini explosion
            
            if(e.type === 'splitter') {
                for(let i=0; i<2; i++) enemies.push({ x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, hp: 15, speed: 3, radius: 12, color: '#ff2e63', type: 'basic', dmg: 5, xp: 5, angle: 0 });
            }

            Sound.explode(); score += e.xp; sharedXP += e.xp;
            if(sharedXP >= xpToNext) { sharedLevel++; sharedXP = 0; xpToNext = Math.floor(xpToNext * 1.3); triggerUpgrade(); }
            ultimateCharge = Math.min(maxUltimate, ultimateCharge + 5);
            xps.push({x: e.x, y: e.y});
            if(Math.random() < 0.05) healthPacks.push({x: e.x, y: e.y});
            spawnParticles(e.x, e.y, 15, e.color);
            enemies.splice(idx, 1);
        }

        function updatePickups(ts) {
            xps.forEach((x, i) => {
                let target = players.find(p => !p.dead && Math.hypot(p.x - x.x, p.y - x.y) < 200);
                if(target) { x.x += (target.x - x.x) * 0.15 * ts; x.y += (target.y - x.y) * 0.15 * ts; if(Math.hypot(target.x - x.x, target.y - x.y) < 30) { playerGainXP(target, x); xps.splice(i,1); } }
            });
            healthPacks.forEach((h, i) => {
                players.forEach(p => { if(!p.dead && Math.hypot(p.x - h.x, p.y - h.y) < 40) { p.hp = Math.min(p.maxHp, p.hp + 30); Sound.heal(); spawnFloatingText(p.x, p.y, "REPAIRED", "#00ff00"); healthPacks.splice(i,1); } });
            });
        }

        function playerGainXP(p, x) { sharedXP += 10; Sound.play(800 + Math.random()*200, 'sine', 0.05, 0.05); if(sharedXP >= xpToNext) { sharedLevel++; sharedXP = 0; xpToNext = Math.floor(xpToNext * 1.3); triggerUpgrade(); } }

        function updateFloatingTexts(ts) {
            for(let i=floatingTexts.length-1; i>=0; i--) {
                let t = floatingTexts[i]; t.y -= 1.5 * ts; t.life -= ts;
                if(t.life <= 0) floatingTexts.splice(i,1);
            }
        }
        function spawnFloatingText(x, y, text, color) { floatingTexts.push({x, y, text, color, life: 40}); }

        function spawnParticles(x, y, count, color) { for(let i=0; i<count; i++) particles.push({x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 1.0, color}); }
        function updateParticles(ts) {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx * ts; p.y += p.vy * ts; p.life -= 0.04 * ts;
                if(p.life <= 0) particles.splice(i,1);
            }
        }

        function updateOrbitals(ts) {
            if(sharedOrbitals <= 0) return;
            const t = frameCount * 0.05;
            players.forEach(p => {
                if(p.dead) return;
                for(let i=0; i<sharedOrbitals; i++) {
                    let ang = t + (i * Math.PI*2/sharedOrbitals);
                    let ox = p.x + Math.cos(ang)*70; let oy = p.y + Math.sin(ang)*70;
                    enemies.forEach((e, idx) => { if(Math.hypot(e.x - ox, e.y - oy) < e.radius + 15) { e.hp -= 5; spawnParticles(e.x, e.y, 2, e.color); if(e.hp <= 0) killEnemy(idx); } });
                }
            });
        }

        function triggerUpgrade() {
            gameState = 'PAUSED'; Sound.levelup();
            document.getElementById('upgrade-modal').style.display = 'flex';
            const opts = [
                {id: 'CHAIN', t: 'CHAIN ARC', d: 'Lightning Jumps', i: '‚ö°', r: true},
                {id: 'SHOTGUN', t: 'SHOTGUN', d: 'Short Range, Spread', i: 'üî´', r: true},
                {id: 'RAILGUN', t: 'RAILGUN', d: 'Piercing Beam', i: 'üî¶', r: true},
                {id: 'MISSILE', t: 'MISSILE', d: 'Homing Explosives', i: 'üöÄ', r: true},
                {id: 'dmg', t: 'POWER UP', d: 'Damage +20%', i: 'üí•', r: false},
                {id: 'spd', t: 'THRUSTERS', d: 'Speed +10%', i: 'üí®', r: false},
                {id: 'orb', t: 'GUARDIAN', d: '+1 Orbital', i: '‚öõ', r: false}
            ];
            
            const choices = opts.sort(() => 0.5 - Math.random()).slice(0, 3);
            const container = document.getElementById('cards-container'); container.innerHTML = '';
            choices.forEach(o => {
                let d = document.createElement('div'); d.className = `upgrade-card ${o.r?'card-rare':''}`;
                d.innerHTML = `<div class="card-icon">${o.i}</div><div class="card-title">${o.t}</div><div class="card-desc">${o.d}</div>`;
                d.onclick = () => applyUpgrade(o.id);
                container.appendChild(d);
            });
        }

        function applyUpgrade(id) {
            players.forEach(p => {
                if(id==='SHOTGUN' || id==='RAILGUN' || id==='MISSILE' || id==='CHAIN') {
                    p.weapon = id;
                    p.fireRate = id==='SHOTGUN' ? 15 : (id==='RAILGUN' ? 20 : 15);
                }
                if(id==='dmg') p.damage *= 1.2;
                if(id==='spd') p.baseSpeed *= 1.1;
            });
            if(id==='orb') sharedOrbitals++;
            gameState = 'PLAYING'; document.getElementById('upgrade-modal').style.display = 'none';
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('score-display').innerText = score;
            document.getElementById('lvl-display').innerText = sharedLevel;
            document.getElementById('xp-bar').style.width = (sharedXP / xpToNext * 100) + '%';
            if(players[0]) document.getElementById('hp-bar-1').style.width = (Math.max(0, players[0].hp)/players[0].maxHp*100) + '%';
            if(players[1]) document.getElementById('hp-bar-2').style.width = (Math.max(0, players[1].hp)/players[1].maxHp*100) + '%';
            document.getElementById('ult-fill').style.height = (ultimateCharge/maxUltimate*100) + '%';
            if(ultimateCharge >= maxUltimate) ultBtn.classList.add('ready'); else ultBtn.classList.remove('ready');
        }

        function gameOver() {
            gameState = 'GAMEOVER'; Sound.gameover();
            if(score > highScore) { highScore = score; localStorage.setItem('pulu_highscore', highScore); }
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').innerText = "SCORE: " + score;
        }

    </script>
</body>
</html>